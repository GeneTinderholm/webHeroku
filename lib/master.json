[
  {
    "id": "0",
    "title": "Listeners and Routing",
    "date": "Nov 20, 2017",
    "body":
      "<p>In this blog post I would like to cover two things that are fundamental to our current experience on the web, but up until recently gave me quite a bit of trouble conceptually, hopefully this can help some poor student cramming before a test (as so many blog posts have helped me in the past). Let's take the first one first. </p>\n<p>Listeners are everywhere and they are quite useful when dealing with asynchronous programming. I've found that the mental model given in classes and implied by the name confuses some people, and if you get lost here, everything that builds on top of it seems like a quagmire of mystifying technobabble. Listeners aren't lying in wait, checking everything your computer does to see if it is time to carry out their mission. They aren't even lisenting for the thing they are waiting for (as the name would seem to imply). This is much too active a mental model.</p>\n<p>Listeners are post-it notes. Nothing more. They are put in a special place that your computer knows to check, and when something that matches the discription you left happens, your computer runs the code you left. It is the computing equivalent of leaving a post-it note on the fridge for your spouse saying: \"If it is Thursday, buy eggs.\"</p>\n<p>Your spouse checks the fridge on Monday and does nothing, Tuesday and does nothing, Wednesday and does nothing, then checks again on Thursday and buys eggs. You could have just texted your spouse on Thursday to remind them to buy eggs (synchronously), but let's imagine you're out of town for the week on business and your days are so crammed full that you aren't going to be able to remember.</p>\n<p>Post-it notes. Seriously, that's all they are.</p>\n<p>Now for the second topic here. Routing, which made absolutely no sense to me until the first one clicked. Routing is just a very elaborate system for leaving listeners. If the user requests this domain, grab this data, modify it, and send it back to them. If they request this other domain, grab this other data, modify it differently, and send it to them. The routes are just post-it notes again and the directions are your callback function. Post-it notes on the world's biggest fridge, except this fridge happens to be tucked away in a data-center somewhere.</p>"
  },
  {
    "id": "1",
    "title": "Websockets Explained",
    "date": "Nov 27, 2017",
    "body":
      "<p>It is time for part two of my quest to befriend college students that have put off studying for way too long.</p>\n<p>Today's subject: Websockets in Node (specifically socket.io).</p>\n<p>Ok, let's get the boiler plate out of the way, the following two lines go in your javascript file.</p>\n<pre>\nconst io = require('socket.io')(server);\napp.use('/socket.io',express.static(__dirname + 'node_modules/socket.io-client/dist/'));\n</pre>\n<p>The first line should be self explanatory, the only catch being that you have to pass in whatever server you're using for the project. </p>\n<p>The second line assumes you are using express, if not make sure to modify the code in the next section to directly link to the socket.io file.</p>\n<p>The following two lines go within your HTML file (or whatever templating file you happen to be using).</p>\n<pre>\n&#60script src=\"/socket.io/socket.io.js\"&#62</pre>\n</pre>\n<p>This line goes in your within your <code>&#60head&#62</code> section. If you aren't using express, this is the line that need to refer directly to the socket.io.js file within your 'node_modules' folder.</p>\n<pre>\nconst socket = io.connect('http://localhost:3000');\n</pre>\n<p>This line goes within a <code>&#60script&#62</code> tag, preferably after the end of the <code>&#60body&#62</code>. Replace 'localhost:3000' with whatever host/port your server is listening on.</p>\n<p>Now, this next part seems complicated, but we covered listeners last time, remember? They're just post-it notes. This is all just a very elaborate system of notes left for the computer telling it what to do when the specified event happens. </p>\n<p>The first event is always called 'connection' and it passes in a socket object. After this, you are free to call the events whatever you want and pass whatever objects you like as long as you are consistent between your index and HTML files. So the first line of code in the javascript file, assuming you set up everything as the example did, will look something like this: <code>io.on('connection', socket => {</code> and afterwards you will define your callback funtion. It is best to place some listeners on the client so that you can respond to events. </p>\n<p>This is hard for some people, I find that to be because you are so used to conceptualizing what happens with one file as staying within that single file. A self-contained unit of code that you have expertly crafted and this screws up that entire mental model. A good trick is to open the javascript and HTML file side by side and just jump between them as the event would. This allows you to go through the process linearly instead of having to figure out where you are each time, plus if you get lost it's easier to retrace the events that lead to what you are currently working on. Remember you're always starting in the HTML file, you connect, the javascript file recieves a 'connection' event you do some stuff and emit your own events back to the HTML file.</p>\n<p>The only catch here is how you emit the events. There are two main ways. <code>socket.emit</code> will send the event to that specific socket, <code>io.emit</code> will send the event to every socket connected to your server. You will screw it up at least once, no big deal.</p>\n<p>See, easy?</p>\n<p>Now go out there and be great, I'm rooting for you.</p>\n"
  },
  {
    "id": "2",
    "title": "Testing with Jasmine",
    "date": "Dec 04, 2017",
    "body":
      "<p>You still haven't been studying, have you?</p>\n<p>That's alright, the best time to start is now.  </p>\n<p>Today we're going to take a look at testing with Jasmine. </p>\n<p>Jasmine is a framework for testing your javascript code. If you can get this down, you really shouldn't need to keep littering your code with console.logs to figure out what exactly went wrong. </p>\n<p>Let's start at the beginning. Installing jasmine and jasmine-node will be required here (a simple npm install should suffice). The tests must live in a 'spec' folder (running jasmine init) will automatically create this. Further all jasmine test files will need to end in either 'spec' or 'Spec' (by default). </p>\n<p>Ok, the setup is out of the way. Next comes the building blocks of our tests. These tests are, for the most part, broken down into three blocks. The 'describe' block and the 'it' block. When complete, they will look a little something like the following.</p>\n<pre>\ndescribe( 'messageOne', () => {\n  //setup code\n  beforeEach( () => {\n    //code to run before each test\n  });\n  it( 'messageTwo', () => {\n    //code to run for the test\n    expect( result ).toEqual( 'result you expect' );\n  });\n});\n</pre>\n<p>First, the 'describe' block. It takes a message and a callback function. Nothing mysterious here.</p>\n<p>Inside the describe is the 'beforeEach' block. This will be executed before every one of your it tests.</p>\n<p>Last we have the 'it' block. This is one handles the actual test. It also takes a message and a callback, but at the end of it all the result of the test is compared to what you expect the result to be (usually a hard coded value). Something to keep in mind is that there are a few versions of equality checking in Jasmine. .toEqual, which I have used should be used for checking objects. Another variant toBe does strict checking (the equivalent of === and will return false on any objects that aren't stored in the same area of memory, even if all properties are the same). There are other testing functions, but this isn't the time or place to get into them.</p>\n<p>So that's it. Your testing is set up, your code passes the test layed out before it, everything is gravy, right?</p>\n<p>Well, not quite. If all code worked perfectly, testing would be useless. The interresting stuff happens when a test fails. You remember those messages you passed into the describe and it blocks? Here is why you did it. When a test fails, Jasmine will display both of those messages so that you exactly what went wrong, along with the values of the test and a stack trace. So a failure for the sample test up top would look a little something like this:</p>\n<pre>\n1) messageOne messageTwo\nMessage:\n  Expected 'This software summoned Cthulhu' to equal 'result you expect'.\nStack:\n  Error: Expected 'This software summoned Cthulhu' to equal 'result you expect'.\n  at whywouldyoudothiswearegonnadie.process.then.whatever (PATH TO YOUR CODE.js:XX:YY)\n</pre>\n<p>Not terribly useful for trivial programs with one or two tests, but one day you will have a codebase of thousands of lines and a nice message along with what went wrong is going to save what is left of your sanity. </p>\n<p>Now go out there and be awesome. I'm rooting for you.</p>\n"
  },
  {
    "id": "3",
    "title": "Understanding sequelize",
    "date": "Dec 11, 2017",
    "body":
      "<p>Let's face it. Sequelize is kind of a pain. If you're anything like me you've been in the middle of a coding session when you realize the query you just made is wrong. The wrong data is coming back, the wrong data is showing up, your house is burning down, and the entire region rumbles as Cthulu rises from the waves. Something went wrong. You look at the 75 line monstrosity birthed from a combination of laziness and rushed madness, your shoulders slump and your heart fills with despair. You've committed the worst sin of all. You've got a typo somewhere.</p>\n<p>This is going to take a while to comb through.</p>\n<p>Wait! There's a better way. Ok, well... not for you. Not this time.</p>\n<p>But next time there's a better way. </p>\n<p>You don't have to assign everything within the parentheses of your find/findAll/whatever function.</p>\n<p>It's just an object. Set it bit by bit. This also has the benefit of allowing you to dynamically create your search.</p>\n<p>How? Well, your search needs an object with certain key-value pairs. Give it one. Then pass that object into your query function. If you're dealing with a database of customers and need to get the first and last names of user 137, the following should do:</p>\n<pre>\nlet queryObject = {};\nqueryObject.where = {};\nqueryObject.attributes = ['fname', 'lname'];\nqueryObject.where.userId = 137;\nUser.find(queryObject);\n</pre>\n<p>Alright, but does it handle more complex operators? Yes, that's what bracket notation is for.</p>\n<pre>\nqueryObject.where[Sequelize.Op.or] = [{userId: 137}, {userId: 256}];\n</pre>\n<p>Preferably you would set Sequelize.Op to just Op, it's much cleaner that way.</p>\n<p>No more nested objects that make your code look more like the response from an API request than something written by a human being. No more mixing so many arrays and objects that your code looks like lisp that can't render properly.</p>\n<p>But there's an added benefit. One that really unlocks the power within database querying. You can decide what parameters to set throughout your program. Let's say you've promised your kid a toy for Christmas. If she's been good, it will be one that costs more than $20. Before you would have had to type:</p>\n<pre>\nif(daughterHasBeenGood){\n  Toy.find({\n    where: {\n      price: {\n        [Op.gt]: 10\n      }\n    }\n  });\n} else {\n  Toy.find({\n    where: {\n      price: {\n        [Op.lte]: 10\n      }\n    }\n  });\n}\n</pre>\n<p>That's just lunacy! Pretty soon we'll have 40 years of darkness, earthquakes, volcanoes, human sacrifice, dogs and cats will live together! This just won't do.</p>\n<p>Don't worry, there's a better way.</p>\n<pre>\nlet queryObject = {};\nqueryObject.where = {};\nif(daughterHasBeenGood){\n  queryObject.where.price = { [Op.gt]: 10 };\n} else {\n  queryObject.where.price = { [Op.lte]: 10 };\n}\nToy.find(queryObject);\n</pre>\n<p>See? Much more reasonable.</p>\n<p>Now go out there and be awesome. I'm rooting for you.</p>\n"
  },
  {
    "id": "4",
    "title": "Using Array.map with async/await",
    "date": "Dec 18, 2017",
    "body":
      "<p>It's that time again, your code isn't working. It's due in a few hours isn't it?</p>\n<p>You tried to use await with and Array.map, didn't you?</p>\n<p>Ok, good news, your computer is working exactly how it should. We haven't wandered into a non-deterministic realm where elder gods lurk behind every corner. Well, we probably haven't, I haven't seen your code.</p>\n<p>The bad news is that await doesn't work the way you expect, at least not here.</p>\n<p>Let's take a look under the hood of async/await.</p>\n<p>Wait, come back, this isn't going to turn into a lecture, there's just a few things you have to understand about asynchronous functions in javascript. It's important that you understand these things if you want to understand why your code doesn't run.</p>\n<p>Await doesn't magically turn your asynchronous code into synchronous code. It's just a different way of interacting with promises. Trust me, this is a good thing. To actually run it as a synchronous function, you would need access to data that doesn't exist yet.</p>\n<ol>\n<li>Your computer can't handle all of the data that doesn't exist yet.</li>\n<li>You so do not want to deal with all of it.</li>\n<li>Inventing time-travel is a sure-fire way to end up at a government black-site. You don't have time for this, you have a deadline, remember?</li>\n</ol>\n<p>But doesn't await make my program wait for the data to be created and returned before continuing? Isn't that the whole point?</p>\n<p>Yes. Yes it is. And your computer is doing a magnificent job of it. I'm willing to bet good money that you wrote something like the following:</p>\n<pre>\nlet resultArray = await arrayName.map(x => {\n  //asynchronous code here\n});\n</pre>\n<p>I'm not far off am I? Don't be embarassed, I've done it too. The problem here is that you awaited a synchronous function. It doesn't matter to the computer that the function calls asynchronous functions, as far as the computer is concerned you told it to wait for a result. It got back an array of promises and it went on its merry way down the rest of your code.</p>\n<p>You awaited the part inside the function as well, why is it even returning anything?</p>\n<p>Yeah, I'm not going to lie, that part is kinda stupid.</p>\n<p>But I digress, back to your problem here. There are two ways to solve your problem. Both of them, fortunately for you, are rather easy and involve no callback functions or then chains. I promise.</p>\n<p>Option 1: Promise.all</p>\n<p>Come back, you're fine. I said there would be no thens and I meant it. Promise.all is awaitable.</p>\n<p>Add this line to your code below the map function:</p>\n<pre>\nlet newArray = await Promise.all(resultArray);\n</pre>\n<p>Done. No I'm not kidding, it's that easy. No, I don't know why you had to end up on the 5th page of google looking through some nobody's blog post to find this out.</p>\n<p>What? I said there was another option? Oh, yes. Yes there is.</p>\n<p>Option 2: The humble for loop.</p>\n<p>This one involves deleting your existing map function, but it goes a little something like this:</p>\n<pre>\nlet resultArray = [];\nfor(let i = 0; i < arrayName.length; i++){\n  resultArray[i] = await asyncronousFunction(arrayName[i]);\n}\n</pre>\n<p>Replace that middle line with the code you actually need to run.</p>\n<p>Don't be down on yourself. The whole map thing isn't that obvious. This gets everybody at some point. But if it were that easy, nobody would pay you to do this, would they?</p>\n<p>Now go out there and be awesome. I'm rooting for you.</p>\n"
  },
  {
    "id": 5,
    "title": "Basic Routing with React",
    "date": "Jan 02, 2018",
    "body":
      "<p>Today I'm going to cover basic route switching in react. </p>\n<p>Despite what this is called, you don't necessarily have to render an entirely new page in each route (though you, of course, are able to). If you have a heading and a sidebar that you want to keep constant on every page, there's no reason you can't drop your router down into the app and only switch the content portion of your app (be careful with this, if requirements change and you suddenly do need to get rid of an element you thought was \"permanent\" on a page, you will have to completely refactor your app).</p>\n<p>So, let's get started.</p>\n<p>First you are going to have to import a few things from the `react-router-dom` package like this:</p>\n<pre>\nimport {\n  BrowserRouter as Router,\n  Route,\n  Switch\n} from 'react-router-dom';\n</pre>\n<p>You will also need to import whatever components you will be swtiching between, for the sake of brevity, I will be using the following:</p>\n<pre>\nconst Hello = () => &#60h1&#62Hello&#60/h1&#62\nconst World = () => &#60h1&#62World&#60/h2&#62\n</pre>\n<p>These should, in any non-trivial application, be stored elsewhere and not defined in the router.</p>\n<p>Within the router, simply specify your routes within a switch component.</p>\n<p>The example for this application would be something like the following.</p>\n<pre>\n&#60Router&#62\n  &#60Switch&#62\n    &#60Route exact path=\"/\" component={Home} /&#62\n    &#60Route exact path=\"/world\" component={World} /&#62\n  &#60/Switch&#62\n&#60/Router&#62\n</pre>\n<p>Now when someone visits www.yoursuperawesomewebsite.com they'll see a big, beautiful \"Hello\", and if they go to www.yoursuperawesomewebsite.com/world they'll see a slightly smaller (but just as beautiful) \"World\".</p>\n<p>Be careful to remember the \"exact\" on, at the very least, the root path. If you don't, the root path will match every route (since they all begin with a \"/\").</p>\n<p>You can ignore the exact under certain circumstances where you want to have groups of routes all use the same component. You can also define anonymous callback functions within the router itself, but I think those are matters for a different blog post.</p>\n<p>Now go out there and be awesome. I'm rooting for you.</p>\n "
  },
  {
    "id": 6,
    "title": "The Two Sum Problem",
    "date": "Jan 24, 2018",
    "body":
      "<p>Today I'm going to look at the two sum problem, a common interview question.</p>\n<p>Premise: Given an array of numbers, find all the pairs of array elements that have a particular sum.</p>\n<p>Example I/O:</p>\n<pre>\nInput: [-4, 2, 1, 9, 7, 5, 3, 0]\nExpected Output: [ [ 2, 1 ], [ -4, 7 ], [ 3, 0 ] ] \n</pre>\n<p>First let's tackle the naive solution. Nested for loops. Never a good idea, but in a time crunch, they will do the job. The naive solution is going to look a little something like this:</p>\n<pre>\nconst findSlowSum = (array, sum) => {\n  let results = []\n  for(let i = 0; i < array.length; i++){\n    for(let j = i + 1; j < array.length; j++){\n      if(array[i] + array[j] == sum){\n        results.push([array[i], array[j]]);\n      }\n    }\n  }\n  return results;\n}\n</pre>\n<p>Not pretty, but it does accomplish the task. However it's going to run in O(n^2) time, the function is going to have to make n checks of n other numbers to exhaust all possible options.</p>\n<p>We can do better than that. Let's try using a hashing function to keep track of which items we've used already.</p>\n<pre>\nconst findFastSum = (array, sum) => {\n  let results = [];\n  let hashObj = {};\n  for(let i = 0; i < array.length; i++){\n    if(hashObj[sum - array[i]] != undefined){\n      results.push([hashObj[sum - array[i]], array[i]]);\n    } \n    hashObj[array[i]] = array[i];\n  }\n  return results;\n}\n</pre>\n<p>Because accessing an object can be done in O(1) time, we only have to make n O(1) checks, this solution results in O(n) time.</p>\n<p>Nested loops, do have their place, such as accessing every element of a matrix, and they are a powerful tool. But the impulse to use them should make you stop and think if there is a more efficent way to solve the problem.</p>\n<p>Now go out there and be awesome. I'm rooting for you.</p>\n"
  }
]
